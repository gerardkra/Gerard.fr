clear
funcprot(0)

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//EXO 1
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

 function [u, gu, nit] = gradient_pas_cst( u0, df, pas, nitmax, eps )
   
   nit = 0 ;
   gu0 = df(u0) ;
   u = u0 ; 
   gu = gu0 ;
   while( ( norm(gu) /norm(gu0) > eps ) & ( nit < nitmax ) )
       u = u - pas * gu ;
       gu = df(u) ;
       nit = nit + 1 ; 
   end
       
 endfunction

x = linspace(-1,1) ;
scf(0); clf() ;
title( 'Exo 1, question 2, x^2+sin(x)' )
plot(x,x.^2+sin(x))

function y=df(x)
    y = 2*x+cos(x);
endfunction
u0 = 0.0 ;
pas = 0.01 ;
nitmax = 10000 ;
eps = 1e-8 ;
[u, dfu, nit] = gradient_pas_cst( u0, df, pas, nitmax, eps )
printf( 'Exo 1, question 2, le minimum est atteint en %6.4f en %d iterations\n', u, nit )

x = linspace(-2,2) ;
y = linspace(-2,2) ;
[xx,yy]=meshgrid(x,y) ;
zz = (xx-ones(xx)).^2+10*(yy-ones(yy)).^2 ;
scf(1) ; clf()
title( 'Exo 1, question 3, 1ere fonction' )
surf(xx,yy,zz)
scf(2) ; clf()
title( 'Exo 1, question 3, 1ere fonction' )
contour(x,y,zz',40)

function v=df1(u)
    x = u(1) ; y = u(2) ;
    v(1) = 2*(x-1) ;
    v(2) = 20*(y-1) ;
endfunction
u0 = [0;0] ;
pas = 0.01 ;
nitmax = 10000 ;
eps = 1e-8 ;
[u, dfu, nit] = gradient_pas_cst( u0, df1, pas, nitmax, eps )
printf( 'Exo 1, question 3, 1ere fonction, le minimum est atteint en (%5.3f,%5.3f) en %d iterations\n', u(1), u(2), nit )


x = linspace(-2,2) ;
y = linspace(-2,2) ;
[xx,yy]=meshgrid(x,y) ;
zz = (xx-ones(xx)).^2+10*(xx.^2-yy).^2 ;
scf(3) ; clf() ;
title( 'Exo 1, question 3, 2eme fonction' )
surf(xx,yy,zz)
scf(4)
title( 'Exo 1, question 3, 2eme fonction' )
contour(x,y,zz',40)

function v=df2(u)
    x = u(1) ; y = u(2) ;
    v(1) = 2*(x-1) + 40*x*(x^2-y) ;
    v(2) = -20*(x^2-y) ;
endfunction
u0 = [0;0] ;
pas = 0.01 ;
nitmax = 10000 ;
eps = 1e-8 ;
[u, dfu, nit] = gradient_pas_cst( u0, df2, pas, nitmax, eps )
printf( 'Exo 1, question 3, 2eme fonction, le minimum est atteint en (%5.3f,%5.3f) en %d iterations\n', u(1), u(2), nit )


N = 5;
A = rand(2,N);
function y=dg(x)
    y = zeros(x) ;
    for i=1:N
        y = y + (x-A(:,i))/norm(x-A(:,i)) ;
    end
endfunction
u0 = [2;2] ;
pas = 0.01 ;
nitmax = 10000 ;
eps = 1e-8 ;
[u, dfu, nit] = gradient_pas_cst( u0, dg, pas, nitmax, eps )
printf( 'Exo 1, question 4, nombre d''iterations = %d\n', nit )
scf(5) ; clf() ;
title( 'Exo 1, question 4, sum(norm(x-Ai))' )
plot(A(1,:),A(2,:),'xb')
plot(u(1),u(2),'xr')


function y=dh(x)
    y = 2 * [1:length(x)]' .* x ;
endfunction

n = 5 ;
u0 = ones(n,1) ;
pas = 0.01 ;
nitmax = 10000 ;
eps = 1e-8 ;
[u, dfu, nit] = gradient_pas_cst( u0, dh, pas, nitmax, eps )
printf( 'Exo 1, question 5, gradient pas fixe, le minimum est atteint en (%5.3f,%5.3f,%5.3f,%5.3f,%5.3f) en %d iterations\n', u(1), u(2), u(3), u(4), u(5), nit )

//Placons les iterees sur le graphique
n = 2 ;
u0 = 2*ones(n,1) ;
pas = 0.05 ;
nitmax = 10000 ;
eps = 1e-4 ;
x = linspace(-2,2) ;
y = linspace(-2,2) ;
[xx,yy]=meshgrid(x,y) ;
zz = xx.^2 + 2 * yy.^2 ;
scf(6) ; clf() ;
title( 'Exo 1, question 5, x^2+2*y^2 avec les iterees du gradient a pas fixe' ) 
xset("fpf"," ") ; contour(x,y,zz',80) ; 
nit = 0 ;
dfu0 = dh(u0) ;
u = u0 ; 
dfu = dfu0 ;
plot( u(1),u(2), 'rx' ) 
while( ( norm(dfu) /norm(dfu0) > eps ) & ( nit < nitmax ) )
    u = u - pas * dfu ;
    dfu = dh(u) ;
    nit = nit + 1 ;
    plot( u(1),u(2), 'rx' ) 
end


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//EXO 2
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function [u, gu, nit] = gradient_pas_optimal( u0, A, b, nitmax, eps )
   nit = 0 ;
   gu0 = 0.5*(A+A')*u0-b ;
   u = u0 ;
   gu = gu0 ;
   while( ( norm(gu)/norm(gu0) > eps ) & ( nit < nitmax ) )
       res = A*u-b ; 
       rho = res'*res / (res'*(A*res)) ;
       u = u - rho * gu ;
       gu = 0.5*(A+A')*u-b ;
       nit = nit + 1 ;
   end    
endfunction

//Reprenons le dernier exemple du l'exo 1
n = 5 ;
A = diag([1:n]) ;
b = zeros(n,1) ;
u0 = ones(n,1) ;
nitmax = 10000 ;
eps = 1e-8 ;
[u, dfu, nit] = gradient_pas_optimal( u0, A, b, nitmax, eps )
printf( 'Exo 2, question 1, gradient pas optimal, le minimum est atteint en (%5.3f,%5.3f,%5.3f,%5.3f,%5.3f) en %d iterations\n', u(1), u(2), u(3), u(4), u(5), nit )

//Placons les iterees sur le graphique
n = 2 ;
A = diag([1:n]) ;
b = zeros(n,1) ;
u0 = 2*ones(n,1) ;
nitmax = 10000 ;
eps = 1e-4 ;
x = linspace(-2,2) ;
y = linspace(-2,2) ;
[xx,yy]=meshgrid(x,y) ;
zz = xx.^2 + 2 * yy.^2 ;
scf(7) ; clf() ;
title( 'Exo 2, question 1, x^2+2*y^2 avec les iterees du gradient a pas optimal' ) 
contour(x,y,zz',80)
nit = 0 ;
gu0 = 0.5*(A+A')*u0-b ;
u = u0 ;
gu = gu0 ;
plot( u(1),u(2), 'rx' ) 
while( ( norm(gu)/norm(gu0) > eps ) & ( nit < nitmax ) )
    res = A*u-b ; 
    rho = res'*res / (res'*(A*res)) ;
    u = u - rho * gu ;
    gu = 0.5*(A+A')*u-b ;
    nit = nit + 1 ;
    plot( u(1),u(2), 'rx' ) 
end 



function [u,nit] = gradient_conjugue( u0, A, b, nitmax, eps )
   nit = 0 ;
   res0 = b-A*u0 ;
   u = u0 ;
   res = res0 ;
   des = res0 ;
   while( ( norm(res)/norm(res0) > eps ) & ( nit < nitmax ) )
       rho = res'*des / (des'*(A*des)) ;
       u = u + rho * des ;
       res = b - A*u ;
       ll = - (res'*(A*des))/ (des'*(A*des));
       des = res + ll*des ;
       nit = nit + 1 ;
   end    
endfunction

//Reprenons le dernier exemple du l'exo 1
n = 5 ;
A = diag([1:n]) ;
b = zeros(n,1) ;
u0 = ones(n,1) ;
nitmax = 10000 ;
eps = 1e-8 ;
[u, nit] = gradient_conjugue( u0, A, b, nitmax, eps )
printf( 'Exo 2, question 2, gradient conjugue, le minimum est atteint en (%5.3f,%5.3f,%5.3f,%5.3f,%5.3f) en %d iterations\n', u(1), u(2), u(3), u(4), u(5), nit )

//Placons les iterees sur le graphique
n = 2 ;
A = diag([1:n]) ;
b = zeros(n,1) ;
u0 = 2*ones(n,1) ;
nitmax = 10000 ;
eps = 1e-4 ;
x = linspace(-2,2) ;
y = linspace(-2,2) ;
[xx,yy]=meshgrid(x,y) ;
zz = xx.^2 + 2 * yy.^2 ;
scf(8) ; clf() ;
title( 'Exo 2, question 2, x^2+2*y^2 avec les iterees du gradient conjugue' ) 
contour(x,y,zz',80)
nit = 0 ;
res0 = b-A*u0 ;
u = u0 ;
res = res0 ;
des = res0 ;
plot( u(1),u(2), 'rx' ) 
while( ( norm(res)/norm(res0) > eps ) & ( nit < nitmax ) )
    rho = res'*des / (des'*(A*des)) ;
    u = u + rho * des ;
    res = b - A*u ;
    ll = - (res'*(A*des))/ (des'*(A*des));
    des = res + ll*des ;
    nit = nit + 1 ;
    plot( u(1),u(2), 'rx' ) 
end 

//Le gradient conjugue donne la solution exacte en n iterations

    
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//EXO 3
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

n = 100 ;
x = rand(n,1) ;
// on regarde des points autour de la droite 2*x+1
y = 2*x+1 + 0.5*(rand(n,1)-0.5) ;

A = [ ones(n,1) x ] ;
c = y ;

//Resolution directe de l'equation normale
coef = (A'*A) \ (A'*c) ; 

//Avec la methode QR
[Q,R]=qr(A) ;
mat = R(1:2,1:2) ;
rhs = Q'*c ; rhs = rhs(1:2) ;
coefqr = mat \ rhs ; 

scf(9) ; clf() ;
plot(x,y,'+')
xx = linspace(min(x),max(x)) ;
plot(xx,coefqr(1) + coefqr(2)*xx ,'r')
printf( 'Exo 3, Les points sont localises autour de la droite y=2x+1\n' )
printf( '     >> la droite de regression obtenue est y=%5.3f x + %5.3f\n', coefqr(2), coefqr(1) )

n = 100 ;
x = rand(n,1) ;
// on regarde des points autour de la parabole 3*x^2+2*x+1
y = 3*x.^2 + 2*x+1 + 0.5*(rand(n,1)-0.5) ;


A = [ ones(n,1) x x.^2 ] ;
c = y ;

//Resolution directe de l'equation normale
coef = (A'*A) \ (A'*c) ; 

//Avec la methode QR
[Q,R]=qr(A) ;
mat = R(1:3,1:3) ;
rhs = Q'*c ; rhs = rhs(1:3) ;
coefqr = mat \ rhs ; 

scf(10) ; clf() ;
plot(x,y,'+')
xx = linspace(min(x),max(x)) ;
plot(xx,coefqr(1) + coefqr(2)*xx + coefqr(3)*xx.^2,'r')
printf( 'Exo 3, Les points sont localises autour de la parabole y=3x^2+2x+1\n' )
printf( '     >> la parabole de regression obtenue est y=%5.3f x^2+ %5.3f x + %5.3f\n', coefqr(3), coefqr(2), coefqr(1) )