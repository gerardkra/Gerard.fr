\documentclass{article}
\usepackage{amsmath}

\begin{document}

\title{Exercise: Analysis of a File Containing City Population Data}
\author{}
\date{}
\maketitle

\section*{Tasks}

Perform the following tasks:

\begin{enumerate}
    \item \textbf{Read the file ``cities.csv'' with SCALA}:
    \begin{itemize}
        \item The file can be read with the command \texttt{sc.textFile("cities.csv")}, where \texttt{sc} is the Spark context. 
        \item Use the command \texttt{sc.textFile("cities.csv").take(1001)} to load the first 1001 lines and inspect the data.
    \end{itemize}
    
    \item \textbf{Count the lines of the result}:
    \begin{itemize}
        \item Count the number of lines in the file to verify that the data has been loaded correctly. This can be done using the \texttt{.count()} function.
    \end{itemize}
    
    \item \textbf{Filter the file to remove the header}:
    \begin{itemize}
        \item Filter the file to remove the headline (the first row), which contains the column names. 
        \item Hint: use the \texttt{filter} function and \texttt{!line.startsWith("City")} to exclude the header line.
    \end{itemize}
    
    \item \textbf{Map the file to split each line into fields}:
    \begin{itemize}
        \item Use a \texttt{map} function to split each line into its respective fields (i.e., columns). 
        \item Each field corresponds to the columns ``City'', ``Country'', and ``Population''. 
        \item For this task, you can use \texttt{line.split(",")} to separate the fields by commas.
    \end{itemize}
    
    \item \textbf{Retrieve the population column}:
    \begin{itemize}
        \item Use a \texttt{map} function to retrieve the field corresponding to ``Population''. 
        \item Convert the population field, which is a string, to an integer using \texttt{.toInt}. 
        \item The population field is the third column (index \texttt{2}).
    \end{itemize}
    
    \item \textbf{Filter the collection of population values}:
    \begin{itemize}
        \item Filter the population collection to retain only records where the population is greater than 0. 
        \item The final collection will be called \texttt{collectPopulations}.
    \end{itemize}
    
    \item \textbf{Use a MapReduce function to compute the total number of cities}:
    \begin{itemize}
        \item Code a MapReduce function to compute the total number of cities in \texttt{collectPopulations}. 
        \item The result will be stored in the variable \texttt{countCities}.
    \end{itemize}
    
    \item \textbf{Use a reduce function to compute the total sum of city populations}:
    \begin{itemize}
        \item Code a reduce function to compute the total population of all cities. 
        \item The result will be stored in the variable \texttt{totalPopulation}.
    \end{itemize}
    
    \item \textbf{Use a reduce function to compute the maximum population of a city}:
    \begin{itemize}
        \item Code a reduce function to compute the maximum population of a city. 
        \item The result will be stored in the variable \texttt{maxPopulation}. 
        \item What can you conclude from this result?
    \end{itemize}
    
    \item \textbf{Compute and print on screen}:
    \begin{itemize}
        \item Compute and display the following results:
        \begin{itemize}
            \item Total population
            \item Number of cities
            \item Maximum city population
            \item Average city population
        \end{itemize}
    \end{itemize}
\end{enumerate}

\section*{Expected Scala Code}

Here's a general idea of how your code could look. Adjust it according to the exact structure of the \texttt{cities.csv} file.

\begin{verbatim}
    // Step 1: Read the file
    val file = sc.textFile("cities.csv")

    // Step 2: Count the number of lines
    val lineCount = file.count()
    println(s"Number of lines: $lineCount")

    // Step 3: Filter to remove the header
    val dataWithoutHeader = file.filter(line => !line.startsWith("City"))

    // Step 4: Split each line into fields (City, Country, Population)
    val columns = dataWithoutHeader.map(line => line.split(","))

    // Step 5: Retrieve the Population field (third column) and convert it to an integer
    val populations = columns.map(fields => fields(2).toInt)

    // Step 6: Filter to keep only populations greater than 0
    val collectPopulations = populations.filter(pop => pop > 0)

    // Step 7: Compute the total number of cities
    val countCities = collectPopulations.count()

    // Step 8: Compute the total population
    val totalPopulation = collectPopulations.reduce(_ + _)

    // Step 9: Compute the maximum population of a city
    val maxPopulation = collectPopulations.reduce((a, b) => Math.max(a, b))

    // Step 10: Compute the average population
    val averagePopulation = totalPopulation / countCities

    // Print the results
    println(s"""
      | Total number of cities: $countCities
      | Total population: $totalPopulation
      | Maximum city population: $maxPopulation
      | Average city population: $averagePopulation
    """.stripMargin)
\end{verbatim}

\section*{Dataset Structure}

The dataset (\texttt{cities.csv}) is assumed to have the following columns:

\begin{verbatim}
City, Country, Population
New York, USA, 8419600
Los Angeles, USA, 3980400
Paris, France, 2148000
...
\end{verbatim}

This exercise is a good parallel to the \texttt{les-arbres.csv} problem but works with city population data, and it introduces similar MapReduce operations to compute counts, sums, maximums, and averages.

\end{document}

